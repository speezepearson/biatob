syntax = "proto3";

package biatob.proto.mvp;

message UserId {
  oneof kind {
    string username = 1;
    // string oauth_google_acct = 2;
    // string oauth_facebook_acct = 3;
  }
}

message AuthToken {
  bytes hmac_of_rest = 1;
  UserId owner = 2;
  uint64 minted_unixtime = 3;
  uint64 expires_unixtime = 4;
}

// For MVP purposes, we're just gonna store the entire worldstate in a protobuf blob. "Data base"? Huh?
// TODO(P3): ^ stop doing that
message WorldState {

  map<string, UsernameInfo> username_users = 1;
  // map<string, GoogleOauthInfo> google_oauth_users = 5;
  // map<string, FacebookOauthInfo> facebook_oauth_users = 6;

  map<uint64, Market> markets = 2;

  message GenericUserInfo {
    repeated UserId trusted_users = 1;
  }
  message UsernameInfo {
    GenericUserInfo info = 1;
    bytes password_bcrypt = 2;
  }
  // message GoogleOauthInfo {
  //   GenericUserInfo info = 1;
  // }
  // message FacebookOauthInfo {
  //   GenericUserInfo info = 1;
  // }
  message Market {
    // Set upon creation, never changed
    string question = 1;
    CertaintyRange certainty = 2;
    uint64 maximum_stake_cents = 3;
    uint64 created_unixtime = 4;
    uint64 closes_unixtime = 5;
    string special_rules = 6;
    UserId creator = 7;

    // Changes regularly
    repeated Trade trades = 8;
    Resolution resolution = 9;
  }

  message Trade {
    UserId bettor = 1;
    bool bettor_expected_resolution = 2;
    uint64 bettor_stake = 3;
    uint64 transacted_unixtime = 4;
  }
}


enum Void {
  VOID = 0;
}

enum Resolution {
  RESOLUTION_NONE_YET = 0;
  RESOLUTION_YES = 1;
  RESOLUTION_NO = 2;
}

message Position {
  int64 win_cents_if_yes = 1;
  int64 win_cents_if_no = 2;
}

message WhoamiRequest {}
message WhoamiResponse {
  AuthToken auth = 1;
}

message RegisterUsernameRequest {
  string username = 1;
  string password = 2;
}
message RegisterUsernameResponse {
  oneof register_username_result {
    Void ok = 1;
    Error error = 2;
  }
  message Error {
    string catchall = 1;
    Void username_taken = 2;
  }
}

message CertaintyRange {
  float low = 1;
  float high = 2;
}
message MarketPrivacy {
  oneof privacy_kind {
    Void all_trusted_by_author = 1;
    Emails specific_users = 2;
  }
  message Emails {
    repeated string emails = 1;
  }
}
message CreateMarketRequest {
  string question = 2;
  MarketPrivacy privacy = 3;
  CertaintyRange certainty = 4;
  uint64 maximum_stake_cents = 5;
  uint64 open_seconds = 6;
  string special_rules = 7;
}
message CreateMarketResponse {
  oneof create_market_result {
    uint64 new_market_id = 1;
    Error error = 2;
  }
  message Error {
    string catchall = 1;
  }
}

message GetMarketRequest {
  uint64 market_id = 2;
}
message GetMarketResponse {
  oneof get_market_result {
    Market market = 1;
    Error error = 2;
  }
  message Market {
    string question = 1;
    CertaintyRange certainty = 2;
    uint64 maximum_stake_cents = 3;
    uint64 remaining_yes_stake_cents = 4;
    uint64 remaining_no_stake_cents = 5;
    uint64 created_unixtime = 6;
    uint64 closes_unixtime = 7;
    string special_rules = 8;
    UserInfo creator = 9;
    Resolution resolution = 10;
  }
  message Error {
    string catchall = 1;
    Void no_such_market = 2;
  }
}
message UserInfo {
  string display_name = 1;
}

message StakeRequest {
  uint64 market_id = 2;
  bool expected_resolution = 3;
  uint64 stake = 4;
}
message StakeResponse {
  oneof stake_result {
    Void ok = 1;
    Error error = 2;
  }
  message Error {
    string catchall = 1;
  }
}

message GetUserRequest {
  string email = 2;
}
message GetUserResponse {
  oneof get_user_result {
    User user = 1;
    Error error = 2;
  }
  message User {
    bool trusted_by_requester = 1;
    bool trusts_requester = 2;
  }
  message Error {
    string catchall = 1;
  }
}

message MarkTrustedRequest {
  string email_to_trust = 2;
}
message MarkTrustedResponse {
  oneof result {
    Void ok = 1;
    Error error = 2;
  }
  message Error {
    string catchall = 1;
  }
}
